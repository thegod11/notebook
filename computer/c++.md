### 1，红黑树

- ①添加节点：默认红色节点，当父节点是红色时，看叔叔节点为黑时，将祖父变红父亲变黑，进行左旋右旋，将父亲移到上面。祖父当做新的添加节点，重复....

- ②删除节点的时候，不是叶子节点时，与子节点的值进行交换直到是叶子节点。
  叶子节点时，若为黑色，则总体思路是将父节点变位黑色，或是兄弟节点变红，加上左旋右旋，（还要看兄弟节点的子节点颜色）使得依然每条路径黑色相同。

<font color='red'>这些调整都是为了满足每条路径的黑色数量相同。</font>

### 2，设计模式

为了在有变化点的情况下，维持稳定点。
由设计原则演变过来：
	①接口隔离原则：1.类封装时，用 权限限定词实现 ，用户无需关心的函数使用private  2.类与类依赖使用接口（容器存储接口）
	②最少知道原则（迪米特）：接口隔离，也就有了这个原则的思想
	③单一职责原则：类中函数只有固定一个变化方向，比如基类只负责流程的骨架
	④开闭原则：对拓展（继承：基类使用虚函数，多态组合: 用基类指针做成员）开放，对修改关闭
私有、公有、保护继承：就是对于基类中的公有、保护成员的访问权限不同，继承访问不了私有成员。protected是对子类开放的权限。

<font color='red'>※ 稳定点使用抽象解决，变化点使用拓展解决。</font>

### 3，观察者模式：一对多的依赖关系中，“一”的变化要让所有“多”都感知到。

可以将所有观察者，继承同一个接口，封装一个基类的list（“多”），每次只需将新增加的观察者加到这个list中即可。需要展示的时候，“一”只需遍历当前观察者list。
观察者自己调用attach与detach

+ ①面向接口：观察者都继承一个基类接口

+ ②接口隔离：容器存储接口观察者类

### 4，策略模式：用户调用算法，提供参数，算法有很多具体实现----->用来消除if，else

​	①接口隔离：依赖注入：两个类的依赖通过一个接口：接口指针
​	②面向接口
​	③开闭原则：稳定点的抽象不会修改，但是继承接口可以拓展

