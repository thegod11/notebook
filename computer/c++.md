### 1，红黑树

- ①添加节点：默认红色节点，当父节点是红色时，看叔叔节点为黑时，将祖父变红父亲变黑，进行左旋右旋，将父亲移到上面。祖父当做新的添加节点，重复....

- ②删除节点的时候，不是叶子节点时，与子节点的值进行交换直到是叶子节点。
  叶子节点时，若为黑色，则总体思路是将父节点变位黑色，或是兄弟节点变红，加上左旋右旋，（还要看兄弟节点的子节点颜色）使得依然每条路径黑色相同。

<font color='red'>这些调整都是为了满足每条路径的黑色数量相同。</font>

### 2，设计模式

- ==马戏团按顺序表演四个节目，节目内容会更新==

为了在有变化点的情况下，维持稳定点。
由设计原则演变过来：
	①接口隔离原则：1.类封装时，用 权限限定词实现 ，用户无需关心的函数使用private  2.类与类依赖使用接口（容器存储接口）
	②最少知道原则（迪米特）：接口隔离，也就有了这个原则的思想
	③单一职责原则：类中函数只有固定一个变化方向，比如基类只负责流程的骨架
	④开闭原则：对拓展（继承：基类使用虚函数，多态组合: 用基类指针做成员）开放，对修改关闭
私有、公有、保护继承：就是对于基类中的公有、保护成员的访问权限不同，继承访问不了私有成员。protected是对子类开放的权限。

<font color='red'>※ 稳定点使用抽象解决，变化点使用拓展解决。</font>

### 3，观察者模式：一对多的依赖关系中，“一”的变化要让所有“多”都感知到。

- ==一个数据中心，多个显示屏==

可以将所有观察者，继承同一个接口，封装一个基类的list（“多”），每次只需将新增加的观察者加到这个list中即可。需要展示的时候，“一”只需遍历当前观察者list。
观察者自己调用attach与detach

+ ①面向接口：观察者都继承一个基类接口

+ ②接口隔离：==容器存储接口观察者类==

### 4，策略模式：用户调用算法，提供参数，算法有很多具体实现----->用来消除if，else

- ==商场不同季节采用不同促销策略==

​	①接口隔离：依赖注入：两个类的依赖通过一个接口：==接口指针==
​	②面向接口
​	③开闭原则：稳定点的抽象不会修改，但是继承接口可以拓展

### 5，单例模式

> 稳定点：类只有一个实例，且为全局       
>
> 变化点：多个类都想定义为单例时，能不能复用代码

1. 构造函数、析构函数、静态类指针都private
2. 拷贝构造，赋值构造（重载=）、移动构造函数 = delete ；可以关闭这些函数

> 能用取址符号 & 取出地址的皆为左值，剩下的都是右值。
>
> `int j = getNum() // getNum() 返回值在寄存器里为右值，j为左值`
>
> 移动构造函数接受 &&类型 就是右值引用

3. 静态成员函数返回一个全局的访问点，返回静态类指针

==存在的问题==

3. 静态类指针在全局区可以被释放，但是它指向的堆空间无法释放 $\longrightarrow$ atexit(释放空间的函数)
4. 保证线程安全，双重检查，在第二次检查前加锁。 `lock_guard<mutex> lock(_mutex)`
5. 多核下，编译器、CPU重排，违反顺序一致性。$\longrightarrow$ 将类指针变为atomic 

> atomic 解决可见性问题：load加载其他线程的修改，store使得自己的修改可见
>
> 也可以防止指令重排：load时定义内存模型为memory_order_acquire，store时定义为memory_order_release  （atomic_thread_fence也可以解决执行序问题）
>
> 也可以保证原子性

7. 直接创建一个static成员，即解决了线程安全问题，又解决了内存不释放问题，且只会有一个实例。
8. 使用模板template<typename T> 改变基类，基类的构造、析构函数用protected。后续类只需要继承基类，并设置基类为友元（friend class）$\longrightarrow$  友元可以访问private，基类可以调用子类的构造函数

### 6，工厂模式

> 稳定点：各类有着相同的功能，但有不同的方式
>
> 变化点：同种功能类会增加
>
> ==例如：同一个数据，多种导出方式（xml，json），由用户选择==

创建一个工厂类作为基类，包含一个生成具体对象的虚函数。

各个具体工厂类继承这个基类工厂，实现虚函数，new具体的功能类的对象。

### 7，抽象工厂

就是有多个功能的工厂模式

### 8，责任链：多个对象处理请求，处理对象是链式的传递，直到有处理

> 稳定点：处理流程是稳定的、变化点：处理顺序是可变的、处理的条件、处理对象的个数

==请假流程，1天系统自动处理，3天以内提交给项目经理，3天以上提交给老板处理==

创建handler类，作为链表的一个结点，有自己的条件与处理过程，不能处理时调用next的处理函数。

每个具体的处理对象继承handler类即可。

### 9，装饰器

> 稳定点：顺序无关的增加职责
>
> 变化点：职责会不断膨胀

==计算最终年终工资，包含多种奖金组合==

基类是计算奖金的类，组合基类的指针，实现多态组合。

子类继承基类，实现自己的计算方法并调用指针的计算方法，返回最终奖金。

有新的奖金类型只需要把原来的子类指针传入。

### 10，组合模式

对象组合成树形结构，如游戏中一个人物可以有多个系统，如装备、跑马灯、交友，这些系统还有更详细的功能。

### 11，C++11新特性

#### 1. 智能指针

- 为啥要用？ ① 内存泄漏 ② 共享所有权指针的传播与释放，如多个线程使用同一个对象
- `share_ptr<CLass> ptr = make_shared<Class>("....")` 
- 智能指针有一个指针指向对象，一个指针指向控制信息块（reference count 记录有几个智能指针指向这个块，减为0将对象析构）
- 是线程安全的，但是指向的对象数据修改是不安全的
- 普通裸指针不能赋值给智能指针，.use_count查看有几个指针， .reset() 默认是清空，加参数是重分配对象
- 裸指针可以委托给智能指针管理 `shared_ptr<int> ptr(int *p)`
- unique_ptr 只能用来管理内存，自动释放内存。不能赋值给别人。
- weak_ptr 可以指向share_ptr指向的对象， .lock() 是锁住对象即便有要释放的也得等我用完。

​       .expire() 判断是否可用。weak_ptr 也不会改变引用计数

#### 2. 左值、右值引用

> 左值（&）可以取地址，是放在内存里；右值（&&）不可以取地址，是放在寄存器里

- const & 相当于右值引用，vector的push_back(const int& a) ，但是const & 是不能改变引用变量的值的

- move(变量名) 可以返回一个右值引用 ，==单纯的强制类型转换==，返回的仍然是变量的引用

- 拷贝构造函数对于指针变量的==复制==：新申请一片空间，然后将内容拷贝

  移动构造函数对于指针变量是==移动==：将指针指向原来的空间，原指针设置为null（不会影响新对象）

- forword<int>(x) 是将x转发回赋值用的类型（左、右）`int y = 4;y是左值 forword<int>(y)就是右值引用类型 `

#### 3. 匿名函数

> [](int a, int b) -> {        // [] 是捕获外部变量作为形参
>
> ​	// 函数体
>
> };

- [a] 实现值捕获，[&a] 实现引用捕获，且捕获只在创建时进行。
- [=]、[&] 隐氏值、引用捕获，就是根据函数体去捕获变量；[] 空值默认不捕获任何值。

#### 4. 线程池

- 函数式编程：如同数学中的函数，只关心输入与输出

  - **无状态**：函数不维护任何状态。**函数式编程的核心精神是stateless**。

  - **不可变数据**：**输入数据不可变**，动了输入数据就有危险，所以要返回新的数据集。

- std::ref主要在函数式编程（如`std::bind`）时使用，只有用它才会传入引用。

- thread.join() 是阻塞等待线程结束

- std::thread(运行的函数，对象指针，传入函数的参数)  thread的参数除函数外都可缺省

- .detach() 是主线程放弃对线程的管理，使其独立，不再和当前线程共享任何资源

- move(线程) 将其作为参数传给其他线程时，即将所有权传给其他线程。

  ```cpp
  #include <iostream>
  #include <thread>
  #include <chrono>
  
  void thread_func()
  {
      std::cout << "Thread is running." << std::endl;
      std::this_thread::sleep_for(std::chrono::seconds(3));
      std::cout << "Thread has completed." << std::endl;
  }
  
  int main()
  {
      std::thread t(thread_func);  // 创建一个新线程
      std::thread t2 = std::move(t);  // 将t对象的所有权转移给t2对象
      if (t.joinable()) {
          t.join();  // t对象的所有权已经转移，该语句不会执行
      }
      t2.join();  // 等待t2线程执行完毕
      return 0;
  }

- 使用std::this_thread::yield()函数：该函数可以让当前线程==主动放弃CPU的使用权==，让CPU资源分配给其他线程。调用该函数后，当前线程将进入就绪状态，等待下一次调度。

